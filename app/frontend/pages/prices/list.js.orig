import React from 'react';
import moment from 'moment';
import { testRoles } from '~base/tools';
import api from '~base/api';
import { toast } from 'react-toastify';
import tree from '~core/tree';

import ListPage from '~base/list-page';
import ImportPrices from './import';
import { loggedIn, verifyRole } from '~base/middlewares/';
import Editable from '~base/components/base-editable';

export default ListPage({
  translate: true,
  path: '/catalogs/prices',
  title: 'sideMenu.prices',
  titleSingular: 'catalogs.precio',
  icon: 'list-alt',
  roles:
    'admin, orgadmin, analyst, consultor-level-3, consultor-level-2, manager-level-2, manager-level-3',
  exact: true,
  validate: [loggedIn, verifyRole],
  create: false,
  import: true,
  importComponent: ImportPrices,
  export: true,
  exportRole: 'consultor-level-3',
  exportUrl: '/app/prices',
  breadcrumbs: true,
  breadcrumbConfig: {
    path: [
      {
        path: '/',
<<<<<<< HEAD
        label: 'sideMenu.home',
        current: false
      },
      {
        path: '/',
        label: 'sideMenu.admin',
        current: true
      },
      {
        path: '/',
        label: 'sideMenu.catalogs',
        current: true
      },
      {
        path: '/catalogs/prices',
        label: 'sideMenu.prices',
        current: true
      }
=======
        label: 'Inicio',
        current: false,
      },
      {
        path: '/',
        label: 'Administración',
        current: true,
      },
      {
        path: '/',
        label: 'Catálogos',
        current: true,
      },
      {
        path: '/catalogs/prices',
        label: 'Precios',
        current: true,
      },
>>>>>>> release
    ],
    align: 'left',
  },
  baseUrl: '/app/prices',
  branchName: 'prices',
  detailUrl: '/catalogs/prices/',
  filters: true,
  schema: {
    type: 'object',
    required: [],
    properties: {
      general: { type: 'text', title: 'Buscar' },
    },
  },
  uiSchema: {
    general: { 'ui:widget': 'SearchFilter' },
  },
  getColumns: () => {
<<<<<<< HEAD
    const catalogs = tree.get('rule').catalogs || []
    const catalogItems = catalogs.map((catalog, i) => {
      if (catalog.slug !== 'producto') {
        return (
        {
          'title': 'catalogs.' + catalog.slug,
          'property': '',
          'default': 'N/A',
          'sortable': true,
          formatter: (row) => {
            return row.catalogItems.map(item => {
              if (catalog.slug === item.type) {
                return item.name
              }
            })
          }
        }
        )
      }
    }
    ).filter(item => item)

    let cols =
      [
        {
          'title': 'tables.colId',
          'property': 'product.externalId',
          'default': 'N/A',
          'sortable': true,
          formatter: (row) => {
            if (row.product && row.product.externalId) {
              return row.product.externalId
            }
=======
    const catalogs = tree.get('rule').catalogs || [];
    const catalogItems = catalogs
      .map((catalog, i) => {
        if (catalog.slug !== 'producto') {
          return {
            title: ` ${catalog.name}`,
            property: '',
            default: 'N/A',
            sortable: true,
            formatter: row => {
              return row.catalogItems.map(item => {
                if (catalog.slug === item.type) {
                  return item.name;
                }
              });
            },
          };
        }
      })
      .filter(item => item);
>>>>>>> release

    let cols = [
      {
        title: 'Id',
        property: 'product.externalId',
        default: 'N/A',
        sortable: true,
        formatter: row => {
          if (row.product && row.product.externalId) {
            return row.product.externalId;
          }
<<<<<<< HEAD
        },
        {
          'title': 'tables.colProduct',
          'property': 'product',
          'default': 'N/A',
          'sortable': true,
          formatter: (row) => {
            if (row.product && row.product.name) {
              return row.product.name
            }
=======
>>>>>>> release

          return 'N/A';
        },
      },
      {
        title: 'Producto',
        property: 'product',
        default: 'N/A',
        sortable: true,
        formatter: row => {
          if (row.product && row.product.name) {
            return row.product.name;
          }

          return 'N/A';
        },
<<<<<<< HEAD
        ...catalogItems,
        {
          'title': 'catalogs.precio',
          'property': 'price',
          'default': 'N/A',
          'sortable': true,
          'className': 'editable-cell',
          formatter: (row) => {
            if (row && (row.price || row.price === 0)) {
              let price = row.price.toFixed(2).replace(/./g, (c, i, a) => {
                return i && c !== '.' && ((a.length - i) % 3 === 0) ? ',' + c : c
              })
              if (!testRoles('consultor-level-3, consultor-level-2')) {
                return (
                  <Editable
                    value={price}
                    type='text'
                    obj={row}
                    width={100}
                    prepend='$'
                    moneyInput
                    handleChange={async (value, row) => {
                      try {
=======
      },
      ...catalogItems,
      {
        title: 'Precio',
        property: 'price',
        default: 'N/A',
        sortable: true,
        className: 'editable-cell',
        formatter: row => {
          if (row && (row.price || row.price === 0)) {
            let price = row.price.toFixed(2).replace(/./g, (c, i, a) => {
              return i && c !== '.' && (a.length - i) % 3 === 0 ? ',' + c : c;
            });
            if (!testRoles('consultor-level-3, consultor-level-2')) {
              return (
                <Editable
                  value={price}
                  type="text"
                  obj={row}
                  width={100}
                  prepend="$"
                  moneyInput
                  handleChange={async (value, row) => {
                    try {
                      if (Number(value) !== Number(row.price)) {
>>>>>>> release
                        const res = await api.post('/app/prices/' + row.uuid, {
                          price: value,
                        });
                        if (!res) {
                          return false;
                        }
<<<<<<< HEAD
                        // TODO: translate

                        toast('¡Precio guardado!', {
                          autoClose: 3000,
                          type: toast.TYPE.INFO,
                          hideProgressBar: true,
                          closeButton: false
                        })

                        return res
                      } catch (e) {
                        toast('Error: ' + e.message, {
                          autoClose: 3000,
                          type: toast.TYPE.ERROR,
                          hideProgressBar: true,
                          closeButton: false
                        })
                        return false
=======
                        toast('¡Precio guardado!: ', {
                          autoClose: 5000,
                          type: toast.TYPE.INFO,
                          hideProgressBar: true,
                          closeButton: false,
                        });
                        return res;
>>>>>>> release
                      }
                    } catch (e) {
                      toast('Error: ' + e.message, {
                        autoClose: 5000,
                        type: toast.TYPE.ERROR,
                        hideProgressBar: true,
                        closeButton: false,
                      });
                      return false;
                    }
                  }}
                />
              );
            } else {
              return '$ ' + price;
            }
          }

          return 'N/A';
        },
      },

<<<<<<< HEAD
        {
          'title': 'tables.colCreated',
          'property': 'dateCreated',
          'default': 'N/A',
          'sortable': true,
          formatter: (row) => {
            return (
            moment.utc(row.dateCreated).local().format('DD/MM/YYYY hh:mm a')
            )
          }
        }
      ]
=======
      {
        title: 'Creado',
        property: 'dateCreated',
        default: 'N/A',
        sortable: true,
        formatter: row => {
          return moment
            .utc(row.dateCreated)
            .local()
            .format('DD/MM/YYYY hh:mm a');
        },
      },
    ];
>>>>>>> release

    return cols;
  },
});
